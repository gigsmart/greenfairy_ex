defmodule GreenFairy.CQL.Adapters.MSSQLTest do
  use ExUnit.Case, async: true

  alias GreenFairy.CQL.Adapters.MSSQL
  alias GreenFairy.CQLAdapterTestHelper, as: Helper

  setup do
    query = Helper.base_query()
    {:ok, query: query}
  end

  describe "adapter behavior" do
    test "implements required callbacks" do
      Helper.assert_adapter_behavior(MSSQL)
    end

    test "capabilities/0 returns expected capabilities" do
      capabilities = MSSQL.capabilities()

      assert capabilities.array_operators_require_type_cast == false
      assert capabilities.supports_json_operators == true
      assert capabilities.supports_full_text_search == true
      assert capabilities.max_in_clause_items == 1000
      assert capabilities.native_arrays == false
      assert capabilities.requires_sql_server_2016_plus == true
      assert capabilities.case_sensitivity_depends_on_collation == true
    end
  end

  describe "supported_operators/2" do
    test "returns scalar operators" do
      operators = MSSQL.supported_operators(:scalar, :string)

      assert :_eq in operators
      assert :_neq in operators
      assert :_like in operators
      assert :_ilike in operators
      assert :_contains in operators
      assert :_icontains in operators
    end

    test "returns limited array operators" do
      operators = MSSQL.supported_operators(:array, :string)

      # MSSQL supports these via OPENJSON
      assert :_includes in operators
      assert :_excludes in operators
      assert :_includes_any in operators
      assert :_is_empty in operators
      assert :_is_null in operators

      # Note: _includes_all requires complex OPENJSON query
    end

    test "returns json operators" do
      operators = MSSQL.supported_operators(:json, :map)

      assert :_contains in operators
      assert :_has_key in operators
    end
  end

  describe "scalar operators" do
    test "_eq operator", %{query: query} do
      result = MSSQL.apply_operator(query, :name, :_eq, "John", [])
      assert Helper.has_where?(result)
    end

    test "_neq operator", %{query: query} do
      result = MSSQL.apply_operator(query, :name, :_neq, "John", [])
      assert Helper.has_where?(result)
    end

    test "_in operator", %{query: query} do
      result = MSSQL.apply_operator(query, :name, :_in, ["John", "Jane"], [])
      assert Helper.has_where?(result)
    end

    test "_nin operator", %{query: query} do
      result = MSSQL.apply_operator(query, :name, :_nin, ["Spam", "Bot"], [])
      assert Helper.has_where?(result)
    end

    test "_is_null operator", %{query: query} do
      result = MSSQL.apply_operator(query, :name, :_is_null, true, [])
      assert Helper.has_where?(result)
    end
  end

  describe "ILIKE emulation with COLLATE" do
    test "_ilike uses Latin1_General_CI_AS collation", %{query: query} do
      result = MSSQL.apply_operator(query, :name, :_ilike, "%JOHN%", [])
      assert Helper.has_where?(result)
      assert Helper.has_fragment?(result, "COLLATE Latin1_General_CI_AS")
    end

    test "_nilike uses NOT LIKE with collation", %{query: query} do
      result = MSSQL.apply_operator(query, :name, :_nilike, "%SPAM%", [])
      assert Helper.has_where?(result)
      assert Helper.has_fragment?(result, "COLLATE Latin1_General_CI_AS")
      assert Helper.has_fragment?(result, "NOT LIKE")
    end

    test "_istarts_with uses collation", %{query: query} do
      result = MSSQL.apply_operator(query, :name, :_istarts_with, "JO", [])
      assert Helper.has_where?(result)
      assert Helper.has_fragment?(result, "COLLATE Latin1_General_CI_AS")
    end

    test "_iends_with uses collation", %{query: query} do
      result = MSSQL.apply_operator(query, :name, :_iends_with, "HN", [])
      assert Helper.has_where?(result)
      assert Helper.has_fragment?(result, "COLLATE Latin1_General_CI_AS")
    end

    test "_icontains uses collation", %{query: query} do
      result = MSSQL.apply_operator(query, :name, :_icontains, "OH", [])
      assert Helper.has_where?(result)
      assert Helper.has_fragment?(result, "COLLATE Latin1_General_CI_AS")
    end
  end

  describe "OPENJSON array operators" do
    test "_includes uses OPENJSON with EXISTS", %{query: query} do
      result = MSSQL.apply_operator(query, :tags, :_includes, "premium", [])
      assert Helper.has_where?(result)
      assert Helper.has_fragment?(result, "EXISTS")
      assert Helper.has_fragment?(result, "OPENJSON")
    end

    test "_excludes uses OPENJSON with NOT EXISTS", %{query: query} do
      result = MSSQL.apply_operator(query, :tags, :_excludes, "spam", [])
      assert Helper.has_where?(result)
      assert Helper.has_fragment?(result, "NOT EXISTS")
      assert Helper.has_fragment?(result, "OPENJSON")
    end

    test "_includes_any uses OPENJSON with INNER JOIN", %{query: query} do
      result = MSSQL.apply_operator(query, :tags, :_includes_any, ["premium", "verified"], [])
      assert Helper.has_where?(result)
      assert Helper.has_fragment?(result, "EXISTS")
      assert Helper.has_fragment?(result, "OPENJSON")
      assert Helper.has_fragment?(result, "INNER JOIN")
    end

    test "_is_empty with true checks for NULL or no rows", %{query: query} do
      result = MSSQL.apply_operator(query, :tags, :_is_empty, true, [])
      assert Helper.has_where?(result)
      assert Helper.has_fragment?(result, "OPENJSON")
      assert Helper.has_fragment?(result, "IS NULL")
      assert Helper.has_fragment?(result, "NOT EXISTS")
    end

    test "_is_empty with false checks for existing rows", %{query: query} do
      result = MSSQL.apply_operator(query, :tags, :_is_empty, false, [])
      assert Helper.has_where?(result)
      assert Helper.has_fragment?(result, "EXISTS")
      assert Helper.has_fragment?(result, "OPENJSON")
    end
  end

  describe "with bindings" do
    test "applies operator with binding", %{query: query} do
      result = MSSQL.apply_operator(query, :name, :_eq, "John", binding: :user)
      assert Helper.has_where?(result)
    end

    test "applies OPENJSON operator with binding", %{query: query} do
      result = MSSQL.apply_operator(query, :tags, :_includes, "premium", binding: :post)
      assert Helper.has_where?(result)
      assert Helper.has_fragment?(result, "OPENJSON")
    end
  end

  describe "edge cases" do
    test "handles NULL values", %{query: query} do
      result = MSSQL.apply_operator(query, :name, :_eq, nil, [])
      assert Helper.has_where?(result)
    end

    test "returns unmodified query for unsupported operator", %{query: query} do
      result = MSSQL.apply_operator(query, :name, :_unsupported_op, "value", [])
      assert result == query
    end

    test "handles empty array for _includes_any", %{query: query} do
      result = MSSQL.apply_operator(query, :tags, :_includes_any, [], [])
      assert Helper.has_where?(result)
    end
  end

  describe "multiple operators" do
    test "can chain multiple OPENJSON operations", %{query: query} do
      result =
        query
        |> MSSQL.apply_operator(:tags, :_includes, "premium", [])
        |> MSSQL.apply_operator(:tags, :_excludes, "spam", [])

      assert length(result.wheres) == 2
      # Both should use OPENJSON
      fragments = Helper.get_all_where_fragments(result)
      assert Enum.count(fragments, &match?({:fragment, _, _}, &1)) == 2
    end

    test "can mix scalar and array operators", %{query: query} do
      result =
        query
        |> MSSQL.apply_operator(:name, :_ilike, "%john%", [])
        |> MSSQL.apply_operator(:age, :_gte, 18, [])
        |> MSSQL.apply_operator(:tags, :_includes, "premium", [])

      assert length(result.wheres) == 3
    end
  end

  describe "T-SQL specific considerations" do
    test "OPENJSON requires SQL Server 2016+" do
      capabilities = MSSQL.capabilities()
      assert capabilities.requires_sql_server_2016_plus == true
    end

    test "case sensitivity depends on collation setting" do
      capabilities = MSSQL.capabilities()
      assert capabilities.case_sensitivity_depends_on_collation == true
    end

    test "handles special characters in patterns", %{query: query} do
      result = MSSQL.apply_operator(query, :name, :_like, "%[test]%", [])
      assert Helper.has_where?(result)
    end

    test "_includes_any properly encodes JSON array" do
      query = Helper.base_query()
      result = MSSQL.apply_operator(query, :tags, :_includes_any, ["test", "value"], [])

      # Should construct proper OPENJSON query
      assert Helper.has_where?(result)
      assert Helper.has_fragment?(result, "OPENJSON")
    end
  end

  describe "performance considerations" do
    test "_in operator limited to 1000 items per capabilities" do
      capabilities = MSSQL.capabilities()
      assert capabilities.max_in_clause_items == 1000
    end

    test "OPENJSON operations may have performance implications" do
      # OPENJSON with EXISTS can be slower than native array operations
      # This is just documenting the trade-off
      query = Helper.base_query()
      result = MSSQL.apply_operator(query, :tags, :_includes, "test", [])

      # Verify it generates a subquery which may impact performance
      assert Helper.has_fragment?(result, "EXISTS")
    end
  end
end
